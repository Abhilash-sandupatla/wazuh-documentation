{"version":3,"file":"static/js/moved-content.min.js.map","sources":["src/js-source/moved-content.js"],"sourcesContent":["const listOfReleases = [\n  '2.1',\n  '3.0',\n  '3.1',\n  '3.2',\n  '3.3',\n  '3.4',\n  '3.5',\n  '3.6',\n  '3.7',\n  '3.8',\n  '3.9',\n  '3.10',\n  '3.11',\n  '3.12',\n  '3.13',\n  '4.0',\n];\n\n/* Get path from query string */\nlet [domain, path] = document.location.href.split('moved-content.html?path=');\n\nlet finalUrl = '';\nlet anchor = '';\ndomain = document.location.protocol + '//' + document.location.host;\nfinalUrl = domain;\n\nif ( path !== undefined ) {\n  [path, anchor] = path.split('#');\n  finalUrl = getRedirectionUrl(domain, path, anchor, listOfReleases);\n}\n\ndocument.location = finalUrl;\n\n/**\n* Given a URL that doesn't exist in current, use the redirect array to retrieve\n* the URL of the latest version of the corresponding content or the URL to not_found\n* @param {string} domain current domain of the documentation\n* @param {string} path path of the original URL\n* @param {string} anchor anchor of the original URL\n* @param {string} listOfReleases ordered list with all the releases available\n* @return {string} The most recent URL to the content that was located in the original URL\n*/\nfunction getRedirectionUrl(domain, path, anchor, listOfReleases) {\n  const notFoundUrl = domain + '/not_found.html';\n  let finalPath = '';\n  let removed = false;\n  let created = false;\n  let relatedRedirect;\n  const excludePaths = [];\n\n  path = '/'+path;\n  if ( path[path.length-1] == '/' ) {\n    path = path + 'index.html';\n  }\n  finalPath = path;\n  tempPath = path;\n  excludePaths.push(path);\n\n  while (tempPath.length > 0) {\n    finalPath = tempPath;\n    tempPath = '';\n    created = false;\n\n    /* Is the path in newUrls? */\n    Object.keys(newUrls).forEach((release) => {\n      let newInRelease = newUrls[release];\n      newInRelease = newInRelease.map((docpath) => docpath[docpath.length-1] == '/' ? docpath + 'index.html' : docpath );\n      if (newInRelease.indexOf(finalPath) > -1 ) {\n        created = release;\n      }\n    });\n    if ( created === false ) {\n      finalPath = notFoundUrl;\n    } else {\n      /* Get related redirections and pick the most recent */\n      relatedRedirect = getRelatedNewestRedirections(redirections, finalPath, created, anchor, excludePaths);\n\n      if (relatedRedirect.length > 0) {\n        /* Get target URL of the most recent redirection */\n        relatedRedirect = relatedRedirect[relatedRedirect.length-1];\n        created = relatedRedirect['created'];\n        tempPath = relatedRedirect['path'];\n        excludePaths.push(tempPath);\n      }\n    }\n  }\n  if ( created !== false ) {\n    /* Is the final path in removedUrls? */\n    removed = false;\n    Object.keys(removedUrls).forEach((release) => {\n      if ( compareReleases(release, created) > 0 ) {\n        let removedInRelease = removedUrls[release];\n        removedInRelease = removedInRelease.map((docpath) => docpath[docpath.length-1] == '/' ? docpath + 'index.html' : docpath );\n        if (removedInRelease.indexOf(finalPath) > -1 ) {\n          removed = release;\n        }\n      }\n    });\n    if ( removed !== false ) {\n      const lastseen = listOfReleases[listOfReleases.indexOf(removed)-1];\n      finalPath = domain + '/' + lastseen + finalPath;\n    } else {\n      finalPath = domain + '/current' + finalPath;\n    }\n  }\n\n  return finalPath;\n}\n\n/**\n* Given a path and a minimum release for said path, retrieves all redirections\n* related to that path occurring from the minimum release on\n* @param {string} redir array of redirections\n* @param {string} currentPath the original path\n* @param {string} created minimum release to consider for the redirections (when the path was created)\n* @param {string} anchor anchor of the original path if any\n* @param {array} excluded list of path to be ignored as a result (they were checked before)\n* @return {array} List of all the related redirection happening after the minimum release\n*/\nfunction getRelatedNewestRedirections(redir, currentPath, created, anchor, excluded) {\n  const relatedTargets = [];\n  let anchorfound = false;\n\n  /* Get only the related redirections (any) */\n  for (let i = 0; i < redir.length; i++) {\n    const redirObject = redir[i];\n    let validRedir = false;\n\n    if ( anchor !== undefined) {\n      /* Paths with anchor have preference if they exist */\n      if ( Object.values(redirObject).indexOf(currentPath+'#'+anchor) != -1 ) {\n        const targets = redirObject['target'];\n        for ( let j = 0; j < targets.length; j++ ) {\n          const targetReleases = targets[j].split('=>');\n          if ( compareReleases(targetReleases[0], targetReleases[1]) < 0\n          && compareReleases(created, targetReleases[0]) <= 0 ) {\n            validRedir = targetReleases[1];\n            anchorfound = true;\n          }\n        }\n      }\n    }\n    if ( anchorfound === false && Object.values(redirObject).indexOf(currentPath) != -1 ) {\n      const targets = redirObject['target'];\n      for ( let j = 0; j < targets.length; j++ ) {\n        const targetReleases = targets[j].split('=>');\n        if ( compareReleases(targetReleases[0], targetReleases[1]) < 0\n        && compareReleases(created, targetReleases[0]) <= 0 ) {\n          validRedir = targetReleases[1];\n        }\n      }\n    }\n\n    if ( validRedir && !excluded.includes(redirObject[validRedir]) ) {\n      relatedTargets.push(\n          {\n            'created': validRedir,\n            'path': redirObject[validRedir],\n          },\n      );\n    }\n  }\n  return relatedTargets;\n}\n\n/**\n* Given 2 release strings, determine their order\n* @param {string} first first release as first operand of the comparisson\n* @param {string} second second release as second operand of the comparisson\n* @return {int} Possible results:\n*     * false => there was an error\n*     * 1 => first is newer\n*     * 0 => same release\n*     * -1 => second is newer\n*/\nfunction compareReleases(first, second) {\n  const firstNumbers = first.split('.');\n  const secondNumbers = second.split('.');\n  if ( firstNumbers.length < 2 || secondNumbers.length < 2 ) {\n    return false;\n  }\n\n  /* Comparing majors */\n  firstNumbers[0] = parseInt(firstNumbers[0]);\n  secondNumbers[0] = parseInt(secondNumbers[0]);\n  /* The major of the first release is newer */\n  if ( firstNumbers[0] > secondNumbers[0] ) {\n    return 1;\n  }\n  /* The major of the second release is newer */\n  if ( firstNumbers[0] < secondNumbers[0] ) {\n    return -1;\n  }\n\n  /* Same major. Comparing minors */\n  firstNumbers[1] = parseInt(firstNumbers[1]);\n  secondNumbers[1] = parseInt(secondNumbers[1]);\n  /* The minor of the first release is newer */\n  if ( firstNumbers[1] > secondNumbers[1] ) {\n    return 1;\n  }\n  /* The minor of the second release is newer */\n  if ( firstNumbers[1] < secondNumbers[1] ) {\n    return -1;\n  }\n  /* Same minor */\n  return 0;\n}\n"],"names":["listOfReleases","domain","path","document","location","href","split","finalUrl","anchor","getRedirectionUrl","relatedRedirect","notFoundUrl","finalPath","removed","created","excludePaths","length","tempPath","push","Object","keys","newUrls","forEach","newInRelease","release","map","docpath","indexOf","getRelatedNewestRedirections","redirections","removedUrls","compareReleases","removedInRelease","redir","currentPath","excluded","relatedTargets","anchorfound","i","redirObject","validRedir","undefined","values","targets","j","targetReleases","includes","first","second","firstNumbers","secondNumbers","parseInt","protocol","host"],"mappings":"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"}