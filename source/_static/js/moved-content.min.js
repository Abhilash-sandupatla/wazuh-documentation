const listOfReleases = [ '2.1', '3.0', '3.1', '3.2', '3.3', '3.4', '3.5', '3.6', '3.7', '3.8', '3.9', '3.10', '3.11', '3.12', '3.13', '4.0', ]; let [domain, path] = document.location.href.split('moved-content.html?path='); let finalUrl = ''; let anchor = ''; domain = document.location.protocol + '//' + document.location.host; finalUrl = domain; if ( path !== undefined ) { [path, anchor] = path.split('#'); finalUrl = getRedirectionUrl(domain, path, anchor, listOfReleases); } document.location = finalUrl; function getRedirectionUrl(domain, path, anchor, listOfReleases) { const notFoundUrl = domain + '/not_found.html'; let finalPath = ''; let removed = false; let created = false; let relatedRedirect; const excludePaths = []; path = '/'+path; if ( path[path.length-1] == '/' ) { path = path + 'index.html'; } finalPath = path; tempPath = path; excludePaths.push(path); while (tempPath.length > 0) { finalPath = tempPath; tempPath = ''; created = false; Object.keys(newUrls).forEach((release) => { let newInRelease = newUrls[release]; newInRelease = newInRelease.map((docpath) => docpath[docpath.length-1] == '/' ? docpath + 'index.html' : docpath ); if (newInRelease.indexOf(finalPath) > -1 ) { created = release; } }); if ( created === false ) { finalPath = notFoundUrl; } else { relatedRedirect = getRelatedNewestRedirections(redirections, finalPath, created, anchor, excludePaths); if (relatedRedirect.length > 0) { relatedRedirect = relatedRedirect[relatedRedirect.length-1]; created = relatedRedirect['created']; tempPath = relatedRedirect['path']; excludePaths.push(tempPath); } } } if ( created !== false ) { removed = false; Object.keys(removedUrls).forEach((release) => { if ( compareReleases(release, created) > 0 ) { let removedInRelease = removedUrls[release]; removedInRelease = removedInRelease.map((docpath) => docpath[docpath.length-1] == '/' ? docpath + 'index.html' : docpath ); if (removedInRelease.indexOf(finalPath) > -1 ) { removed = release; } } }); if ( removed !== false ) { const lastseen = listOfReleases[listOfReleases.indexOf(removed)-1]; finalPath = domain + '/' + lastseen + finalPath; } else { finalPath = domain + '/current' + finalPath; } } return finalPath; } function getRelatedNewestRedirections(redir, currentPath, created, anchor, excluded) { const relatedTargets = []; let anchorfound = false; for (let i = 0; i < redir.length; i++) { const redirObject = redir[i]; let validRedir = false; if ( anchor !== undefined) { if ( Object.values(redirObject).indexOf(currentPath+'#'+anchor) != -1 ) { const targets = redirObject['target']; for ( let j = 0; j < targets.length; j++ ) { const targetReleases = targets[j].split('=>'); if ( compareReleases(targetReleases[0], targetReleases[1]) < 0 && compareReleases(created, targetReleases[0]) <= 0 ) { validRedir = targetReleases[1]; anchorfound = true; } } } } if ( anchorfound === false && Object.values(redirObject).indexOf(currentPath) != -1 ) { const targets = redirObject['target']; for ( let j = 0; j < targets.length; j++ ) { const targetReleases = targets[j].split('=>'); if ( compareReleases(targetReleases[0], targetReleases[1]) < 0 && compareReleases(created, targetReleases[0]) <= 0 ) { validRedir = targetReleases[1]; } } } if ( validRedir && !excluded.includes(redirObject[validRedir]) ) { relatedTargets.push( { 'created': validRedir, 'path': redirObject[validRedir], }, ); } } return relatedTargets; } function compareReleases(first, second) { const firstNumbers = first.split('.'); const secondNumbers = second.split('.'); if ( firstNumbers.length < 2 || secondNumbers.length < 2 ) { return false; } firstNumbers[0] = parseInt(firstNumbers[0]); secondNumbers[0] = parseInt(secondNumbers[0]); if ( firstNumbers[0] > secondNumbers[0] ) { return 1; } if ( firstNumbers[0] < secondNumbers[0] ) { return -1; } firstNumbers[1] = parseInt(firstNumbers[1]); secondNumbers[1] = parseInt(secondNumbers[1]); if ( firstNumbers[1] > secondNumbers[1] ) { return 1; } if ( firstNumbers[1] < secondNumbers[1] ) { return -1; } return 0; } 